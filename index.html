<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Consensus in Distributed Systems — Simple + Exam-Oriented Notes</title>
  <style>
    body{font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;line-height:1.55;color:#111;background:#f7f8fb;padding:28px; margin: auto;}
    h1{font-size:30px;margin-bottom:10px;font-weight:700}
    h2{font-size:22px;margin-top:26px;font-weight:700}
    h3{font-size:18px;margin-top:18px;font-weight:600}
    p{margin:10px 0;font-size:15px}
    li{margin:6px 0;font-size:15px}
    .card{background:white;border-radius:14px;padding:22px;margin:18px 0;box-shadow:0 6px 20px rgba(13,38,76,0.08)}
    .diagram{display:block;margin:14px auto;max-width:100%;background:#fff;padding:10px;border-radius:10px}
    table{border-collapse:collapse;width:100%;margin:12px 0;font-size:15px}
    th,td{border:1px solid #d6d6e7;padding:8px;text-align:left}
    .note{background:#fff9d9;padding:10px;border-left:5px solid #f7ce46;margin:10px 0;border-radius:6px}

    .header{
        display: flex;
        align-items: center;
        justify-content: space-around;
    }
    .header a{
        font-family:'Times New Roman', Times, serif;
        font-weight: bold;
        color:#f7f8fb;
        text-decoration: none;
    }
    .header button{
        background-color: #111;
        padding: 5px;
        border-radius: 5px;
    }
  </style>
</head>
<body>
<div class="header" style="height: 50px; background-color: rgb(4, 80, 80); margin: 0px; padding: 0px;">
 <button><a href="index.html">UNIT 3</a></button>
 <button><a href="4part1.html">UNIT 4(1)</a></button>
 <button><a href="4part2.html">UNIT 4(2)</a></button>
 <button><a href="5part1.html">UNIT 5(1)</a></button>
 <button><a href="5part2.html">UNIT 5(2)</a></button>
</div>

<h1>UNIT 3</h1>
<h1>Consensus in Distributed Systems — Extremely Simple + Exam-Oriented Notes</h1>
<p style="font-size:16px">Prepared in the easiest possible language. Every topic explained slowly, with clear reasoning and diagrams.</p>

<!-- SECTION 1 -->
<div class="card">
  <h2>1. What is Consensus?</h2>
  <p>Consensus means <strong>all the computers (nodes)</strong> in a distributed system must agree on the same value or same decision, even if:</p>
  <ul>
    <li>Some nodes are slow</li>
    <li>Some nodes crash</li>
    <li>Some nodes lie or behave maliciously</li>
  </ul>

  <h3>Why is consensus needed?</h3>
  <p>Because there is <strong>no central boss</strong> in distributed systems or blockchains. All nodes must coordinate.</p>

  <h3>Three properties of consensus</h3>
  <ul>
    <li><strong>Agreement:</strong> All correct nodes must agree on the same value.</li>
    <li><strong>Validity:</strong> The final value must come from one of the nodes (not random garbage).</li>
    <li><strong>Termination:</strong> The algorithm must eventually finish.</li>
  </ul>

  <h3>Simple real-life example</h3>
  <p>Five friends want to decide whether to eat Pizza or Burger. Even if one friend’s phone switches off, the remaining must still agree on one option.</p>
</div>

<!-- SECTION 2 -->
<div class="card">
  <h2>2. Byzantine Generals Problem — Easy Explanation</h2>

  <h3>The story</h3>
  <p>Generals surround a city. They must all attack or all retreat. They send messages using messengers.</p>
  <p>But some generals may be <strong>traitors</strong> who send different messages to different generals.</p>

  <div class="note">This is exactly like malicious nodes in a network.</div>

  <h3>Goal</h3>
  <p>All loyal generals must make the <strong>same decision</strong> even if traitors exist.</p>

  <h3>Important mathematical result</h3>
  <p><strong>To tolerate f malicious nodes, you need at least 3f + 1 total nodes.</strong></p>

  <h3>Diagram</h3>
  <svg class="diagram" viewBox="0 0 900 250" xmlns="http://www.w3.org/2000/svg">
    <rect x="10" y="10" width="880" height="230" rx="10" fill="#fff" stroke="#e6eef8"/>
    <text x="40" y="40" font-size="16" font-weight="700">Byzantine Generals — Simple Visual</text>

    <rect x="60" y="80" width="150" height="50" rx="10" fill="#e8f0fe" stroke="#90a9f8"/>
    <text x="90" y="112">General A</text>

    <rect x="360" y="30" width="150" height="50" rx="10" fill="#e8f0fe" stroke="#90a9f8"/>
    <text x="390" y="62">General B</text>

    <rect x="660" y="80" width="150" height="50" rx="10" fill="#ffe5e5" stroke="#ff9a9a"/>
    <text x="690" y="112">General C (Traitor)</text>

    <line x1="210" y1="105" x2="360" y2="55" stroke="#888" stroke-width="2" marker-end="url(#ar)"/>
    <line x1="510" y1="55" x2="660" y2="105" stroke="#888" stroke-width="2" marker-end="url(#ar)"/>
    <line x1="210" y1="105" x2="660" y2="105" stroke="#888" stroke-width="2" marker-end="url(#ar)"/>

    <defs>
      <marker id="ar" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="#888"></path>
      </marker>
    </defs>
  </svg>

  <p><strong>Traitor sends different messages:</strong></p>
  <ul>
    <li>To A: “Attack”</li>
    <li>To B: “Retreat”</li>
  </ul>
  <p>This causes confusion unless enough honest generals exist.</p>
</div>

<!-- SECTION 3 -->
<div class="card">
  <h2>3. Types of Faults — Crash vs Byzantine</h2>

  <h3>A. Crash Fault</h3>
  <ul>
    <li>Node simply stops working</li>
    <li>It does NOT lie</li>
  </ul>

  <h3>Algorithms that tolerate crash faults</h3>
  <ul>
    <li>Paxos</li>
    <li>Raft</li>
  </ul>

  <h3>The minimum number of nodes required</h3>
  <p><strong>2f + 1 nodes</strong> to tolerate <strong>f</strong> crash faults.</p>

  <h3>B. Byzantine Faults</h3>
  <ul>
    <li>Nodes act maliciously</li>
    <li>Lie or send different data to different nodes</li>
  </ul>

  <h3>Algorithms that tolerate Byzantine faults</h3>
  <ul>
    <li>PBFT</li>
    <li>Tendermint</li>
    <li>HotStuff</li>
  </ul>

  <h3>Minimum nodes required</h3>
  <p><strong>3f + 1 nodes</strong> to tolerate <strong>f</strong> malicious nodes.</p>
</div>

<!-- SECTION 4 -->
<div class="card">
  <h2>4. State Machine Replication (SMR)</h2>

  <h3>Simple meaning</h3>
  <p>Every node maintains the same application state and applies the same operations in the same order.</p>

  <h3>Why is it needed?</h3>
  <p>To make sure all copies of the system behave identically.</p>

  <div class="note">Consensus decides the order of operations.</div>

  <h3>Diagram (easy SMR flow)</h3>
  <svg class="diagram" viewBox="0 0 900 200" xmlns="http://www.w3.org/2000/svg">
    <rect x="10" y="10" width="880" height="180" rx="10" fill="#fff" stroke="#e6eef8"/>
    <text x="40" y="40" font-size="16" font-weight="700">State Machine Replication (SMR)</text>

    <rect x="40" y="80" width="140" height="50" rx="10" fill="#e5f3ff" stroke="#92b7ff"/>
    <text x="75" y="110">Client</text>

    <rect x="260" y="80" width="200" height="50" rx="10" fill="#fff4e5" stroke="#ffc88c"/>
    <text x="300" y="110">Consensus (Orders requests)</text>

    <rect x="520" y="80" width="200" height="50" rx="10" fill="#e5ffe8" stroke="#93ff9f"/>
    <text x="560" y="110">Replicas (Apply in order)</text>

    <line x1="180" y1="105" x2="260" y2="105" stroke="#666" stroke-width="2" marker-end="url(#ar2)"/>
    <line x1="460" y1="105" x2="520" y2="105" stroke="#666" stroke-width="2" marker-end="url(#ar2)"/>

    <defs>
      <marker id="ar2" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="#666"></path>
      </marker>
    </defs>
  </svg>
</div>

<!-- The remaining content will continue with the same simplified style: FLP Impossibility, Lower Bounds, Models, Algorithms (Paxos, Raft, PBFT, Tendermint, PoW/PoS), Choosing Algorithm, Finality, Speed, Scalability, Exam Questions. -->

<div class="card">
  <h2>5. FLP Impossibility — Very Easy Explanation</h2>

  <h3>What FLP says (in one line)</h3>
  <p><strong>In a fully asynchronous system, no deterministic algorithm can guarantee consensus if even 1 node can crash.</strong></p>

  <div class="note">Asynchronous = no timing guarantees (messages can be delayed forever).</div>

  <h3>Why is consensus impossible here?</h3>
  <ul>
    <li>Imagine a node becomes slow.</li>
    <li>Other nodes cannot know whether it is slow or crashed.</li>
    <li>Because of this confusion, they can never be 100% sure what to decide.</li>
  </ul>

  <h3>Example (super simple)</h3>
  <p>Two nodes want to decide 0 or 1. Third node is slow.</p>
  <ul>
    <li>If it sends 0 late → others think it's crashed.</li>
    <li>If it sends 0 early → others include that vote.</li>
  </ul>
  <p>Since network gives no timing guarantees, algorithm can be stuck forever.</p>

  <h3>Diagram</h3>
  <svg class="diagram" viewBox="0 0 900 200">
    <rect x="10" y="10" width="880" height="180" rx="10" fill="#fff" stroke="#e6eef8"/>
    <text x="40" y="40" font-size="16" font-weight="700">Why consensus cannot guarantee termination</text>

    <rect x="60" y="80" width="180" height="50" rx="10" fill="#e5f3ff" stroke="#90b7ff"/>
    <text x="115" y="110">Node A</text>

    <rect x="360" y="80" width="180" height="50" rx="10" fill="#e5ffe8" stroke="#93ff9f"/>
    <text x="415" y="110">Node B</text>

    <rect x="660" y="80" width="180" height="50" rx="10" fill="#fff4e5" stroke="#ffc88c"/>
    <text x="690" y="110">Node C (slow or crashed?)</text>

    <text x="300" y="150" font-size="15">No one can know if C is slow or dead → confusion → no safe decision</text>
  </svg>

  <h3>How real systems bypass FLP</h3>
  <ul>
    <li><strong>Partial synchrony:</strong> assume network becomes normal after some time.</li>
    <li><strong>Randomness:</strong> used by Bitcoin (PoW leader election).</li>
    <li><strong>Timeouts & failure detectors:</strong> used in Raft, Paxos.</li>
  </ul>
</div>

<div class="card">
  <h2>6. Lower Bounds (2f+1 and 3f+1) — Extremely Simple</h2>

  <h3>Crash Faults</h3>
  <p>To tolerate f crash faults:</p>
  <p><strong>You need 2f + 1 total nodes.</strong></p>

  <h3>Why?</h3>
  <p>Because you always need a <strong>majority of honest nodes</strong>.</p>
  <p>If f nodes crash, the remaining (f+1) must still be a majority.</p>

  <h3>Byzantine Faults</h3>
  <p>To tolerate f malicious nodes:</p>
  <p><strong>You need 3f + 1 total nodes.</strong></p>

  <h3>Why?</h3>
  <ul>
    <li>f nodes may be malicious</li>
    <li>f nodes may be confused by the malicious ones</li>
    <li>The honest nodes must still form a strong majority</li>
  </ul>

  <h3>Diagram</h3>
  <svg class="diagram" viewBox="0 0 900 200">
    <rect x="10" y="10" width="880" height="180" rx="10" fill="#fff" stroke="#e6eef8"/>
    <text x="40" y="40" font-size="16" font-weight="700">Why 3f+1 nodes?</text>

    <rect x="120" y="80" width="160" height="50" rx="10" fill="#e5ffe8" stroke="#93ff9f"/>
    <text x="160" y="110">Honest group</text>

    <rect x="360" y="80" width="160" height="50" rx="10" fill="#ffe5e5" stroke="#ff9a9a"/>
    <text x="395" y="110">Malicious f</text>

    <rect x="600" y="80" width="160" height="50" rx="10" fill="#fff4e5" stroke="#ffc88c"/>
    <text x="650" y="110">Confused f</text>
  </svg>
</div>

<div class="card">
  <h2>7. Models & Timing — Simple Explanations</h2>

  <h3>1. Synchronous Model</h3>
  <ul>
    <li>We know message delay limits</li>
    <li>We know processing time limits</li>
    <li>Consensus is easy</li>
  </ul>

  <h3>2. Asynchronous Model</h3>
  <ul>
    <li>No timing guarantees</li>
    <li>Messages may be delayed forever</li>
    <li>Leads to FLP impossibility</li>
  </ul>

  <h3>3. Partially Synchronous Model</h3>
  <ul>
    <li>Most practical</li>
    <li>Network behaves badly at first</li>
    <li>Eventually becomes normal</li>
  </ul>
</div>

<div class="card">
  <h2>8. Classification of Consensus Algorithms — Deep & Easy</h2>
  <p>Consensus algorithms can be classified based on:</p>
  <ul>
    <li>What type of failures they tolerate</li>
    <li>Whether they use a leader or not</li>
    <li>Whether the system is permissioned or permissionless</li>
  </ul>
  <h3>A. Based on Failure Model</h3>
  <ul>
    <li><strong>CFT (Crash Fault Tolerant)</strong> – handles nodes that simply stop responding</li>
    <li><strong>BFT (Byzantine Fault Tolerant)</strong> – handles nodes that lie, cheat, send wrong data</li>
  </ul>
  <h3>B. Based on Leadership</h3>
  <ul>
    <li><strong>Leader-based</strong> – Raft, Multi-Paxos, PBFT (one leader coordinates)</li>
    <li><strong>Leaderless</strong> – Bitcoin PoW (no central leader)</li>
  </ul>
</div>

<div class="card">
  <h2>9. Algorithms — Deep, Slow, Easy</h2>

  <h3>1. Paxos</h3>
  <p>Paxos ensures correctness even if messages are delayed or nodes crash. It uses majority votes.</p>
  <h4>Detailed Steps:</h4>
  <ol>
    <li><strong>Prepare Phase:</strong> Proposer sends proposal number to acceptors.</li>
    <li><strong>Promise:</strong> Acceptors promise not to accept smaller numbers.</li>
    <li><strong>Accept Phase:</strong> Proposer sends value; acceptors accept it.</li>
  </ol>

  <h3>2. Raft</h3>
  <p>Raft is designed to be readable and easy. It has 3 parts:</p>
  <ul>
    <li><strong>Leader Election</strong> – nodes choose a leader using timeouts</li>
    <li><strong>Log Replication</strong> – leader sends entries to followers</li>
    <li><strong>Safety</strong> – ensures logs remain consistent</li>
  </ul>

  <h3>3. PBFT (Practical Byzantine Fault Tolerance)</h3>
  <p>PBFT works when nodes can be malicious. It needs 3f+1 nodes.</p>
  <h4>Phases in Detail:</h4>
  <ul>
    <li><strong>Pre-prepare:</strong> Leader proposes a request</li>
    <li><strong>Prepare:</strong> Nodes verify proposal</li>
    <li><strong>Commit:</strong> Once enough nodes confirm, decision is final</li>
  </ul>

  <h3>4. Tendermint</h3>
  <p>Used in Cosmos. Combines BFT + Proof-of-Stake. Produces fast and final results.</p>

  <h3>5. HotStuff</h3>
  <p>Modern BFT algorithm used in Meta’s Libra. Very simple, linear communication.</p>

  <h3>6. PoW & PoS</h3>
  <p><strong>PoW</strong> – miners solve puzzles. Slow but secure.<br>
     <strong>PoS</strong> – validators stake coins. Fast and energy-efficient.</p>
</div>

<div class="card">
  <h2>10. Choosing the Right Algorithm — More Detail</h2>
  <h3>If your system is:</h3>
  <ul>
    <li><strong>Enterprise / Permissioned</strong> → PBFT / HotStuff / Raft</li>
    <li><strong>Public Blockchain</strong> → PoW / PoS</li>
    <li><strong>High performance, low delay</strong> → Tendermint</li>
    <li><strong>Simple crash tolerance</strong> → Raft</li>
  </ul>
</div>

<div class="card">
  <h2>11. Finality — Deep & Clear</h2>
  <h3>A. Deterministic Finality</h3>
  <p>Once a block is added, it can NEVER be removed. Used in PBFT, Tendermint, HotStuff.</p>

  <h3>B. Probabilistic Finality</h3>
  <p>More confirmations = more confidence. Used in Bitcoin & old Ethereum PoW.</p>
</div>

<div class="card">
  <h2>12. Speed, Performance & Scalability — More Detailed</h2>
  <p>Each algorithm has trade‑offs:</p>
  <ul>
    <li><strong>Paxos/Raft:</strong> Good for small clusters, low latency</li>
    <li><strong>PBFT:</strong> Fast but does not scale well (<100 nodes)</li>
    <li><strong>Tendermint:</strong> Good scalability and fast blocks</li>
    <li><strong>PoW:</strong> Global scalability but slow</li>
  </ul>
</div>

<div class="card">
  <h2>13. Exam Questions — Expanded</h2>
  <h3>Q1. Explain Byzantine Generals Problem with diagram.</h3>
  <h3>Q2. Define FLP impossibility and how systems overcome it.</h3>
  <h3>Q3. Why do BFT systems need 3f+1 nodes?</h3>
  <h3>Q4. Explain Raft leader election.</h3>
  <h3>Q5. Compare PoW, PoS, PBFT.</h3>
</div>

</html>
